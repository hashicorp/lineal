{"version":3,"file":"stack.js","sources":["../../src/transforms/stack.ts"],"sourcesContent":["/**\n * Copyright IBM Corp. 2020, 2026\n */\n\nimport { tracked, cached } from '@glimmer/tracking';\nimport * as shape from 'd3-shape';\nimport { group } from 'd3-array';\n\nimport { Encoding } from '../utils/encoding.ts';\n\nimport type { Accessor } from '../utils/encoding.ts';\n\ntype OrderFn = (series: shape.Series<any, any>) => number[];\ntype OffsetFn = (\n  series: shape.Series<any, any>[],\n  order: Iterable<number>,\n) => void;\ntype Direction = 'vertical' | 'horizontal';\ntype D3StackSeries = shape.Series<{ [key: string]: number }, string>;\ntype D3StackSeriesPoint = shape.SeriesPoint<{ [key: string]: number }>;\n\n/**\n * The set of D3 Stack orders to be referenced by string.\n * [Learn more about D3 Stack orders.](https://github.com/d3/d3-shape#stack-orders)\n */\nexport const ORDERS: { [key: string]: OrderFn } = {\n  appearance: shape.stackOrderAppearance,\n  ascending: shape.stackOrderAscending,\n  descending: shape.stackOrderDescending,\n  insideOut: shape.stackOrderInsideOut,\n  none: shape.stackOrderNone,\n  reverse: shape.stackOrderReverse,\n};\n\n/**\n * The set of D3 Stack offsets to be referenced by string.\n * [Learn more about D3 Stack offsets.](https://github.com/d3/d3-shape#stack-offsets)\n */\nexport const OFFSETS: { [key: string]: OffsetFn } = {\n  expand: shape.stackOffsetExpand,\n  diverging: shape.stackOffsetDiverging,\n  none: shape.stackOffsetNone,\n  silhouette: shape.stackOffsetSilhouette,\n  wiggle: shape.stackOffsetWiggle,\n};\n\n/**\n * The Stack transform is constructed with a configuration object styled after Mark args.\n * This includes x and y accessors (for spatial positioning) and a z accessor (for determining\n * how to divide a dataset for stacking). Additional arguments control how the stacking\n * transform is performed.\n */\nexport interface StackConfig {\n  /** Record-based data, like what would be passed to a Mark component. */\n  data: any[];\n  /** How the x-coordinate of a datum should be determined. */\n  x: Accessor | string;\n  /** How the y-coordinate of a datum should be determined. */\n  y: Accessor | string;\n  /** How the dataset should be divided into data series to be stacked. */\n  z: Accessor | string;\n  /** The algorithm that should be used to determine the order of the stacked data series. */\n  order?: string;\n  /** The algorithm that should be used to determine the offset of the stacked data series. */\n  offset?: string;\n  /**\n   * When true, the order of stacked data series is determined initially and never changed\n   * when the data changes.\n   */\n  stable?: boolean;\n  /**\n   * Which coordinate should be stacked and which should be independent (y stacks when vertical,\n   * x stacks when horizontal). The default is vertical.\n   */\n  direction?: Direction;\n}\n\n/**\n * When a dataset is stacked horizontally, a StackDatumHorizontal represents a single\n * data point within a series within the stack.\n */\nexport interface StackDatumHorizontal {\n  x0: number;\n  x1: number;\n  x: number;\n  y: any;\n  data: { [key: string]: any };\n}\n\n/**\n * When a dataset is stacked vertically, a StackDatumVertical represents a single\n * data point within a series within the stack.\n */\nexport interface StackDatumVertical {\n  y0: number;\n  y1: number;\n  y: number;\n  x: any;\n  data: { [key: string]: any };\n}\n\n/**\n * When calling `myStack.stack` on a horizontal stack, a single datum is returned with the\n * addition of the key that the datum comes from.\n */\nexport interface KeyedStackDatumHorizontal extends StackDatumHorizontal {\n  key: string;\n}\n\n/**\n * When calling `myStack.stack` on a vertical stack, a single datum is returned with the\n * addition of the key that the datum comes from.\n */\nexport interface KeyedStackDatumVertical extends StackDatumVertical {\n  key: string;\n}\n\n/**\n * A series within a stack is an array with two additional properties: `key` that represents\n * the name of the series (derived from the `z` encoding) and `index` that represents the\n * position of the series in the stack.\n *\n * This matches the shapes of series within D3 stacks.\n */\nexport interface StackSeriesHorizontal extends Array<StackDatumHorizontal> {\n  key: string;\n  index: number;\n  visualOrder: number;\n}\n\n/**\n * A series within a stack is an array with two additional properties: `key` that represents\n * the name of the series (derived from the `z` encoding) and `index` that represents the\n * position of the series in the stack.\n *\n * This matches the shapes of series within D3 stacks.\n */\nexport interface StackSeriesVertical extends Array<StackDatumVertical> {\n  key: string;\n  index: number;\n  visualOrder: number;\n}\n\nexport const verticalStackMap = (\n  d: D3StackSeriesPoint,\n): StackDatumVertical => ({\n  y0: d[0],\n  y1: d[1],\n  y: d[1],\n  x: d.data['x'],\n  data: d.data,\n});\n\nexport const horizontalStackMap = (\n  d: D3StackSeriesPoint,\n): StackDatumHorizontal => ({\n  x0: d[0],\n  x1: d[1],\n  x: d[1],\n  y: d.data['y'],\n  data: d.data,\n});\n\nconst tag = (\n  arr: StackDatumVertical[] | StackDatumHorizontal[],\n  { key, index }: D3StackSeries,\n): StackSeriesVertical | StackSeriesHorizontal =>\n  Object.assign(arr, { key, index, visualOrder: 0 });\n\nconst indicesToProperties = (data: D3StackSeries[], isVertical: boolean) => {\n  return isVertical\n    ? data.map(\n        (series) =>\n          tag(series.map(verticalStackMap), series) as StackSeriesVertical,\n      )\n    : data.map(\n        (series) =>\n          tag(series.map(horizontalStackMap), series) as StackSeriesHorizontal,\n      );\n};\n\n/**\n * A transformation class to convert record data into stacked data.\n *\n * ```ts\n * import Stack from '@lineal-viz/transforms/stack';\n *\n *  const stack = new Stack({\n *    // Encodings\n *    x: 'x',\n *    y: 'y',\n *    z: 'group', // The dimension to \"stack\" on\n *\n *    // The direction to stack (also determines the 'value' encoding, here it is y)\n *    direction: 'vertical', // This is also the default\n *\n *    // The data\n *    data: [\n *      { x: 1, y: 3, group: 'A' },\n *      { x: 1, y: 5, group: 'B' },\n *      { x: 1, y: 9, group: 'C' },\n *    ],\n *  });\n * ```\n *\n * A stack object will then lazily compute a stacked version of the same data along the `z`\n * encoding when accessing `stack.data`.\n *\n * ```ts\n * console.log(stack.data);\n *\n * // [\n * //   [ { x: 1, y0: 0, y1: 3, y: 3, data: {...} } ],\n * //   [ { x: 1, y0: 3, y1: 8, y: 8, data: {...} } ],\n * //   [ { x: 1, y0: 8, y1: 17, y: 17, data: {...} } ],\n * // ]\n * ```\n *\n * This transformation is meant to be used with Area and Bar marks to create the common stacked area\n * and stacked bar visualization. Order and Offset options allow for creating specialized variations\n * of these charts, such as stream graphs and baseline-aligned bar charts.\n */\nexport default class Stack {\n  /** Tracked - The data passed into the Stack constructor. */\n  @tracked dataIn: any[] = [];\n\n  // TODO: People will probably want to set these via string since they\n  // are constructed via string?\n  /** Tracked - The D3 stack order algorithm used when stacking data. */\n  @tracked order: OrderFn;\n  /** Tracked - The D3 stack offset algorithm used when stacking data. */\n  @tracked offset: OffsetFn;\n  @tracked _stable = true;\n\n  /** Tracked - How the x encoding in the dataset is accessed. */\n  @tracked xAccessor: Accessor | string;\n  /** Tracked - How the y encoding in the dataset is accessed. */\n  @tracked yAccessor: Accessor | string;\n  /** Tracked - How the z encoding in the dataset is accessed. The z encoding is the property\n   * used to split the dataset into series. */\n  @tracked zAccessor: Accessor | string;\n  /** Tracked - Whether the stack should go vertically (y0, y1) or horizontally (x0, x1). */\n  @tracked direction: Direction;\n\n  #categories: string[] | null = null;\n\n  constructor({\n    order,\n    offset,\n    data,\n    direction,\n    x,\n    y,\n    z,\n    stable,\n  }: StackConfig) {\n    this.offset = (\n      offset ? (OFFSETS[offset] ?? OFFSETS['none']) : OFFSETS['none']\n    )!;\n    this.order = (\n      order\n        ? (ORDERS[order] ?? ORDERS['none'])\n        : this.offset === OFFSETS['wiggle']\n          ? ORDERS['insideOut']\n          : ORDERS['none']\n    )!;\n\n    this.xAccessor = x;\n    this.yAccessor = y;\n    this.zAccessor = z;\n    this.direction = direction ?? 'vertical';\n    this.stable = stable ?? true;\n\n    this.dataIn = data;\n  }\n\n  set stable(val: boolean) {\n    this.#categories = null;\n    this._stable = val;\n  }\n\n  get stable() {\n    return this._stable;\n  }\n\n  @cached get x() {\n    return new Encoding(this.xAccessor);\n  }\n\n  @cached get y() {\n    return new Encoding(this.yAccessor);\n  }\n\n  @cached get z() {\n    return new Encoding(this.zAccessor);\n  }\n\n  @cached get categories(): any[] {\n    return Array.from(new Set(this.dataIn.map((d) => this.z.accessor(d))));\n  }\n\n  #tabulate(data: any[]) {\n    // Transform from records into a table using the x-accessor as ID and the y-accessor as the cell value\n    // (or the y-accessor as ID and the x-accessor as the cell value when stacked horizontally)\n\n    const categories = this.categories;\n    const id = this.direction === 'vertical' ? this.x : this.y;\n    const cell = this.direction === 'vertical' ? this.y : this.x;\n    const idField = this.direction === 'vertical' ? 'x' : 'y';\n\n    const grouped = group(data, id.accessor, this.z.accessor);\n\n    return Array.from(grouped).reduce((rows, [idVal, records]) => {\n      rows.push({\n        [idField]: idVal,\n        ...categories.reduce((columns, category) => {\n          // It is assumed that there is a single record per category, otherwise it would\n          // mean there were duplicate records in the source data.\n          columns[category] =\n            cell.accessor(records.get(category)?.[0] ?? {}) ?? 0;\n          return columns;\n        }, {}),\n      });\n      return rows;\n    }, [] as any[]);\n  }\n\n  /**\n   * An intermediate data representation where data has been converted from a record format\n   * into a tabular format, where rows are determined by the ID field (x when direction is\n   * vertical, y when direction is horizontal) and the Cell field (the opposite of the ID field)\n   * after grouping records by the z accessor.\n   *\n   * ```\n   * [\n   *   { x: 1, y: 5, group: 'A' },\n   *   { x: 1, y: 10, group: 'B' },\n   *   { x: 1, y: 3, group: 'C' },\n   * ]\n   * ```\n   *\n   * Becomes\n   *\n   * ```\n   * [\n   *   { x: 1, A: 5, B: 10, C: 3 }\n   * ]\n   * ```\n   */\n  @cached get table() {\n    return this.#tabulate(this.dataIn);\n  }\n\n  get #stacker() {\n    return shape\n      .stack()\n      .order((this.#categories ? ORDERS['none'] : this.order)!)\n      .offset(this.offset)\n      .keys(this.#categories ?? this.categories);\n  }\n\n  /**\n   * The data passed to the constructor (or `stack.dataIn`) transformed into a stack.\n   *\n   * ```\n   * [\n   *   { x: 1, y: 5, group: 'A' },\n   *   { x: 1, y: 10, group: 'B' },\n   *   { x: 1, y: 3, group: 'C' },\n   *   { x: 2, y: 7, group: 'A' },\n   *   { x: 2, y: 8, group: 'B' },\n   *   { x: 2, y: 5, group: 'C' },\n   * ]\n   * ```\n   *\n   * Becomes\n   *\n   * ```\n   * [\n   *   {\n   *     0: { x: 1, y0: 0, y1: 5, y: 5, data: { ... } },\n   *     1: { x: 2, y0: 0, y1: 7, y: 7, data: { ... } },\n   *     key: 'A',\n   *     index: 0,\n   *   },\n   *   {\n   *     0: { x: 1, y0: 5, y1: 15, y: 15, data: { ... } },\n   *     1: { x: 2, y0: 7, y1: 15, y: 15, data: { ... } },\n   *     key: 'B',\n   *     index: 1,\n   *   },\n   *   {\n   *     0: { x: 1, y0: 15, y1: 18, y: 18, data: { ... } },\n   *     1: { x: 2, y0: 15, y1: 20, y: 20, data: { ... } },\n   *     key: 'C',\n   *     index: 2,\n   *   }\n   * ]\n   * ```\n   *\n   * When `stack.direction` is horizontal, instead of the stack having `y0` and `y1`\n   * properties, it will have `x0` and `x1` properties.\n   */\n  @cached get data(): StackSeriesVertical[] | StackSeriesHorizontal[] {\n    // Convert the table of data into stacks of data.\n    const d3Stack = this.#stacker(this.table).sort((a, b) => a.index - b.index);\n\n    // Once data has been computed once, the category order is persisted for future data stacking.\n    // This prevents the jarring visual re-ordering of series.\n    if (!this.#categories && this.stable) {\n      this.#categories = d3Stack.map((d) => d.key);\n    }\n\n    // Convert the array indexing format to a more Ember friendly property accessor format\n    const stacked = indicesToProperties(d3Stack, this.direction === 'vertical');\n\n    // Annotate the stacked data structure with visual orders\n    const visualOrder = stacked\n      .map((d: StackSeriesVertical | StackSeriesHorizontal) => ({\n        key: d.key,\n        val: this.direction === 'vertical' ? d[0]!.y : d[0]!.x,\n      }))\n      .sort((a, b) => a.val - b.val);\n\n    const orderMap = visualOrder.reduce(\n      (hash: { [key: string]: number }, d, idx) => {\n        hash[d.key] = idx;\n        return hash;\n      },\n      {},\n    );\n\n    stacked.forEach((series) => {\n      series.visualOrder = orderMap[series.key] ?? 0;\n    });\n\n    return stacked;\n  }\n\n  /**\n   * A bound function (for helper compatibility) that takes a slice of data that matches\n   * the shape of `stack.dataIn` and stacks just the slice using the persisted series order\n   * from the initial stacking of the complete dataset.\n   *\n   * This allows for composability with interactors which may be operating on the original\n   * record-based dataset instead of the stack transformed dataset.\n   *\n   * @param slice - A slice of data that matches properties with the original data\n   *                for the stack (the same encodings will be used).\n   */\n  stack = (\n    slice: any[],\n  ): KeyedStackDatumVertical[] | KeyedStackDatumHorizontal[] => {\n    // First table it\n    const table = this.#tabulate(slice);\n\n    // Then stack it\n    const stack = indicesToProperties(\n      this.#stacker(table).sort((a, b) => a.index - b.index),\n      this.direction === 'vertical',\n    );\n\n    // Finally flatten it ([ [{}], [{}], [{}] ] -> [{}, {}, {}] ])\n    // These two mappers are identical, but they are typed differently to prevent the eventual map\n    // from being typed as (StackSeriesVertical | StackSeriesHorizontal)[]\n    const vMap = (d: StackSeriesVertical): KeyedStackDatumVertical => ({\n      ...d[0]!,\n      key: d.key,\n    });\n    const hMap = (d: StackSeriesHorizontal): KeyedStackDatumHorizontal => ({\n      ...d[0]!,\n      key: d.key,\n    });\n    return this.direction === 'vertical'\n      ? (stack as StackSeriesVertical[]).map(vMap)\n      : (stack as StackSeriesHorizontal[]).map(hMap);\n  };\n\n  get stackedCategories() {\n    return this.data.map((d) => d.key).reverse();\n  }\n}\n"],"names":["ORDERS","appearance","shape","stackOrderAppearance","ascending","stackOrderAscending","descending","stackOrderDescending","insideOut","stackOrderInsideOut","none","stackOrderNone","reverse","stackOrderReverse","OFFSETS","expand","stackOffsetExpand","diverging","stackOffsetDiverging","stackOffsetNone","silhouette","stackOffsetSilhouette","wiggle","stackOffsetWiggle","verticalStackMap","d","y0","y1","y","x","data","horizontalStackMap","x0","x1","tag","arr","key","index","Object","assign","visualOrder","indicesToProperties","isVertical","map","series","Stack","g","prototype","tracked","i","constructor","order","offset","direction","z","stable","xAccessor","yAccessor","zAccessor","dataIn","val","_stable","Encoding","n","cached","categories","Array","from","Set","accessor","#tabulate","id","cell","idField","grouped","group","reduce","rows","idVal","records","push","columns","category","get","table","#stacker","stack","keys","d3Stack","sort","a","b","stacked","orderMap","hash","idx","forEach","slice","vMap","hMap","stackedCategories"],"mappings":"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"}