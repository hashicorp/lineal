{"version":3,"file":"mark-utils.js","sources":["../../src/utils/mark-utils.ts"],"sourcesContent":["/**\n * Copyright IBM Corp. 2020, 2026\n */\n\nimport { scheduleOnce } from '@ember/runloop';\n\nimport Bounds from './bounds.ts';\nimport { ScaleIdentity } from './scale.ts';\nimport { Encoding } from './encoding.ts';\n\nimport type { Scale } from './scale.ts';\nimport type { Accessor } from './encoding.ts';\n\n/**\n * A valid Mark component must have a `data` arg.\n */\nexport interface MarkSignature {\n  Args: {\n    data?: any[];\n  };\n}\n\ntype MarkComponent = { args: { data?: any[] } };\n\n/**\n * This is used internally by Marks to qualify a scale with the data arg\n * on the next tick of the runloop (to avoid mutating a property twice in\n * the same render).\n *\n * @param context - A Lineal Mark comonent\n * @param scale - The scale to qualify\n * @param encoding - The encoding whose accesor to use for data lookups\n * @param field - The name of the encoded channel (used for formatting error messages)\n * @throws - When the scale has an invalid range (which is not computed as\n *           part of scale qualification)\n */\nexport function qualifyScale(\n  context: MarkComponent,\n  scale: Scale,\n  encoding: Encoding,\n  field: string,\n  data?: any[],\n): void {\n  if (scale instanceof ScaleIdentity) return;\n\n  const qualificationData = data ?? context.args.data;\n\n  // Bindable closure\n  function afterRender() {\n    scale.domain.qualify(qualificationData, encoding.accessor);\n  }\n\n  if (\n    (scale.domain.__temp_duck_type_bounds || scale.domain instanceof Bounds) &&\n    !scale.domain.isValid\n  ) {\n    // eslint-disable-next-line ember/no-runloop\n    scheduleOnce('afterRender', context, afterRender);\n  }\n\n  if (scale.range instanceof Bounds && !scale.range.isValid) {\n    throw new Error(\n      `Qualifying @${field}Scale: Cannot determine the bounds for a range without a bounding box for the mark.`,\n    );\n  }\n}\n\n/**\n * Given an argument value and maybe a Scale object, determines what Scale should be\n * returned (the Scale, if provided, or an Identity \"pass-through\" scale if the arg is\n * a static value instead of a field or accessor.\n *\n * @param arg - An accessor, typically from a Mark component's args\n * @param scale - A scale, typically from a Mark component's args\n * @returns A scale, either the provided scale or a ScaleIdentity\n */\nexport function scaleFrom(\n  arg: Accessor,\n  scale?: Scale,\n): ScaleIdentity | Scale | undefined {\n  if (typeof arg === 'number' && scale == null) {\n    return new ScaleIdentity({ range: arg });\n  }\n\n  return scale;\n}\n"],"names":["qualifyScale","context","scale","encoding","field","data","ScaleIdentity","qualificationData","args","afterRender","domain","qualify","accessor","__temp_duck_type_bounds","Bounds","isValid","scheduleOnce","range","Error","scaleFrom","arg"],"mappings":";;;;AAAA;AACA;AACA;;;AAWA;AACA;AACA;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,YAAYA,CAC1BC,OAAsB,EACtBC,KAAY,EACZC,QAAkB,EAClBC,KAAa,EACbC,IAAY,EACN;EACN,IAAIH,KAAK,YAAYI,aAAa,EAAE;EAEpC,MAAMC,iBAAiB,GAAGF,IAAI,IAAIJ,OAAO,CAACO,IAAI,CAACH,IAAI;;AAEnD;EACA,SAASI,WAAWA,GAAG;IACrBP,KAAK,CAACQ,MAAM,CAACC,OAAO,CAACJ,iBAAiB,EAAEJ,QAAQ,CAACS,QAAQ,CAAC;AAC5D,EAAA;AAEA,EAAA,IACE,CAACV,KAAK,CAACQ,MAAM,CAACG,uBAAuB,IAAIX,KAAK,CAACQ,MAAM,YAAYI,MAAM,KACvE,CAACZ,KAAK,CAACQ,MAAM,CAACK,OAAO,EACrB;AACA;AACAC,IAAAA,YAAY,CAAC,aAAa,EAAEf,OAAO,EAAEQ,WAAW,CAAC;AACnD,EAAA;AAEA,EAAA,IAAIP,KAAK,CAACe,KAAK,YAAYH,MAAM,IAAI,CAACZ,KAAK,CAACe,KAAK,CAACF,OAAO,EAAE;AACzD,IAAA,MAAM,IAAIG,KAAK,CACb,CAAA,YAAA,EAAed,KAAK,qFACtB,CAAC;AACH,EAAA;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASe,SAASA,CACvBC,GAAa,EACblB,KAAa,EACsB;EACnC,IAAI,OAAOkB,GAAG,KAAK,QAAQ,IAAIlB,KAAK,IAAI,IAAI,EAAE;IAC5C,OAAO,IAAII,aAAa,CAAC;AAAEW,MAAAA,KAAK,EAAEG;AAAI,KAAC,CAAC;AAC1C,EAAA;AAEA,EAAA,OAAOlB,KAAK;AACd;;;;"}