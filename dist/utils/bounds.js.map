{"version":3,"file":"bounds.js","sources":["../../src/utils/bounds.ts"],"sourcesContent":["/**\n * Copyright IBM Corp. 2020, 2026\n */\n\nimport { extent } from 'd3-array';\nimport { tracked } from '@glimmer/tracking';\n\n// Ranges and domains can be specified using an expression similar\n// to Rust's range expression. This validates the expression.\nconst NUMBER_PATTERN = '[+-]?\\\\d+.?\\\\d*';\nconst NUMERIC_RANGE_DSL = new RegExp(\n  `^(${NUMBER_PATTERN})?\\\\.\\\\.(${NUMBER_PATTERN})?$`,\n);\n\n/**\n * A utility class for modeling a min and max value of a type. Bounds can also be constructed\n * and passed around before they are \"qualified\" (i.e., a Bounds can have a `min` but no `max`,\n * a `max` but no `min`, or even neither a `min` or `max`).\n *\n * Being able to create tokens that represent future bounds facilitates in the declarative API\n * used throughout Lineal.\n *\n * When a Bounds instance is ready to be used, it can be qualified with a dataset to compute\n * the `min` and `max` values based on an accessor function, like how the `extent` function\n * from the d3-array package works.\n *\n * @template T - The min/max data type (typically `number`).\n */\nexport default class Bounds<T> {\n  /** The lower bound. When `undefined`, the Bounds instance is invalid. */\n  @tracked min: T | undefined;\n  /** The upper bound. When `undefined`, the Bounds instance is invalid. */\n  @tracked max: T | undefined;\n\n  // TODO: Right now it's possible to first create a piecewise Bounds\n  // and then update the min or the max to be within the steps set in the\n  // constructor. Since piecewise Bounds read straight from steps, setting min\n  // or max has no impact on the bounds getter (which is used in scales). It still\n  // results in a bad surprise from a developer perspective.\n  private steps: T[];\n\n  /** True when the Bounds was constructed with an array with more than two\n   * elements (a min, N pieces, a max). */\n  get isPiecewise() {\n    return this.steps.length > 2;\n  }\n\n  /**\n   * Parses a Bounds instance from a Rust-style range expression.\n   *\n   * ```\n   * const bounds = Bounds.parse('0..');\n   * console.log(bounds.min, bounds.max); // 0, undefined\n   *\n   * const complete = Bounds.parse('-100..100');\n   * console.log(complete.min, complete.max); // -100, 100\n   * ```\n   *\n   * @static\n   * @param input - A Rust-style expression as a string or a numeric array for convience.\n   * @throws - When the provided string is malformed.\n   * @returns - Either a Bounds object or a numeric array (the same one passed as input).\n   */\n  static parse(input: string | number[]): Bounds<number> {\n    if (input instanceof Array) return new Bounds<number>(input);\n\n    if (!NUMERIC_RANGE_DSL.test(input)) {\n      throw new Error(\n        'Invalid string provided as numeric range. Must match the syntax \"1..1\", where the min and the max are both optional (e.g., \"1..\" is valid).',\n      );\n    }\n\n    const [minStr, maxStr] = input.split('..');\n    const min = minStr ? parseFloat(minStr) : undefined;\n    const max = maxStr ? parseFloat(maxStr) : undefined;\n\n    return new Bounds<number>(min, max);\n  }\n\n  /**\n   * TODO: Remove this when https://github.com/ef4/ember-auto-import/pull/512 is released.\n   * Right now in the test-app, Lineal is executed twice (once for the app chunk and again\n   * for the test chunk) which means instanceof checks may not work. Using this gnarly\n   * duck-typing approach is a stopgap.\n   */\n  public readonly __temp_duck_type_bounds: boolean = true;\n\n  /**\n   * Given optional min and max values, construct a Bounds of any type.\n   *\n   * @param [min] - the min value of the bounds, or `undefined` when not yet known.\n   * @param [max] - the max value of the bounds, or `undefined` when not yet known.\n   */\n  constructor(min?: T | T[], max?: T) {\n    if (min instanceof Array) {\n      if (min.length === 0) {\n        this.min = undefined;\n        this.max = undefined;\n        this.steps = [];\n      } else if (min.length === 1) {\n        this.min = min[0];\n        this.max = min[0];\n        this.steps = [min[0]!, min[0]!];\n      } else {\n        this.min = min[0];\n        this.max = min[min.length - 1];\n        this.steps = min.slice();\n      }\n    } else {\n      this.min = min;\n      this.max = max;\n      this.steps =\n        min != undefined && max != undefined ? [min as T, max as T] : [];\n    }\n  }\n\n  /**\n   * True when the scale is \"qualified\" (i.e., has a valid `min` and `max` value).\n   */\n  get isValid(): boolean {\n    return this.min != undefined && this.max != undefined;\n  }\n\n  /**\n   * Replaces `undefined` `min` and `max` values with derived bounds from a provided dataset\n   * using the provided accessor field or function.\n   *\n   * ```\n   * const data = [\n   *   { a: 0, b: 3 },\n   *   { a: -2, b: 5 },\n   *   { a: 10, b: 5 },\n   * ];\n   *\n   * const aBounds = Bounds.parse('..'); // No min or max\n   * aBounds.qualify(data, 'a');\n   * console.log(aBounds.min, aBounds.max); // -2, 10\n   *\n   * const bBounds = Bounds.parse('0..'); // Set min, no max\n   * bBounds.qualify(data, 'b');\n   * console.log(bBounds.min, bBounds.max); // 0, 5\n   * ```\n   *\n   * @param data - An array representing a dataset.\n   * @param  accessor - A function that returns a value for a record in the dataset.\n   *                    When the accessor is a `string`, it is interpreted as a field\n   *                    accessor (e.g., `'foo'` becomes `d => d.foo`)\n   * @throws - When a `min` and `max` cannot be computed using the given dataset and accessor.\n   */\n  qualify(data: any[], accessor: string | ((datum: any) => T)): Bounds<T> {\n    if (this.isPiecewise) {\n      throw new Error(\n        `Cannot qualify a piecewise Bounds. The steps of this Bounds are \"${JSON.stringify(this.steps)}\".`,\n      );\n    }\n\n    if (this.min != undefined && this.max != undefined) return this;\n\n    const fn =\n      typeof accessor === 'string' ? (d: any) => d[accessor] : accessor;\n    const [min, max] = extent(data, fn);\n    if (\n      typeof accessor === 'string' &&\n      (min == undefined || max == undefined)\n    ) {\n      throw new Error(\n        `Invalid extent for data set using field accessor \"${accessor}\". Is \"${accessor}\" defined in this dataset?`,\n      );\n    }\n    if (this.min == undefined) this.min = min;\n    if (this.max == undefined) this.max = max;\n    this.steps = [this.min as T, this.max as T];\n\n    return this;\n  }\n\n  /**\n   * Creates a new Bounds identical to this one.\n   */\n  copy(): Bounds<T> {\n    return this.isPiecewise\n      ? new Bounds<T>(this.steps)\n      : new Bounds<T>(this.min, this.max);\n  }\n\n  /**\n   * A convenient getter for returning the `min` and `max` in a common\n   * two element array format.\n   *\n   * @throws - When the Bounds instance is invalid.\n   */\n  get bounds(): T[] {\n    if (!this.isValid) {\n      throw new Error(\n        'Bounds have not been qualified! These bounds were not constructed with both a min and a max. Use `bounds.qualify` with a dataset to fill in the missing bounds',\n      );\n    }\n\n    if (this.isPiecewise) return this.steps;\n\n    return [this.min as T, this.max as T];\n  }\n}\n"],"names":["NUMBER_PATTERN","NUMERIC_RANGE_DSL","RegExp","Bounds","g","prototype","tracked","i","steps","isPiecewise","length","parse","input","Array","test","Error","minStr","maxStr","split","min","parseFloat","undefined","max","__temp_duck_type_bounds","constructor","slice","isValid","qualify","data","accessor","JSON","stringify","fn","d","extent","copy","bounds"],"mappings":"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"}